# Introduction Computer System



## What is Computer System?

하드웨어와 소프트웨어(프로그램), 데이터를 가지고 인간이 마주한 여러가지 문제를 해결하기 위해 사용되는 시스템

## How do combine HW and SW?

cpu라는 작은 하드웨어 칩으로 메모리라는 물리적 공간에  소프트웨어 또는 프로그램, 데이터를 적재하여 처리한다.

메모리라는 곳에 하드웨어가 처리할 수 있는 데이터, 프로그램을 적재한다.

### 메모리

1. RAM (Random Access Memory)
   1. 프로그램이 실행되기 위해서 하드디스크에 있는 프로그램이 RAM으로 옮겨와진다.
   2. RAM에 적재된 프로그램은 CPU가 한줄 한줄 씩 가져가서 처리한다.
      1. 여기서 한줄 이라는 것은 명령어인데, 프로그램은 수많은 명령어의 집합이다.
2. Hard Disk
   1. 데이터, 프로그램을 영구적으로 저장하는 메모리 공간이다.
   2. 하드디스케에 있는 데이터나 프로그램은 cut-paste가 아닌 copy-paste 되어 RAM으로 옮겨진다.
3. Cache
4. Register

// Cache와 Register는 강의 내용에서 제외

### 이렇게 메모리가 여러개로 나눠진 이유

- 일단 하드디스크는 큰 용량을 가지며 수많은 데이터나 프로그램을 영구적으로 저장시키는 공간이다.
- RAM은 데이터나 프로그램을 적재할 수 있지만 이는 영구적이지 않으며 컴퓨터가 꺼지게 되면 RAM의 있는 모든 데이터나 프로그램은 날아간다. 또한 용량이 적어 하드디스크 만큼의 공간을 가질 수 없다.
- 그러나 RAM은 정말 빠르다.
  - 여기서 빠르다는 것은 access time이 매우 짧다는 뜻이다.
  - 반대로 하드디스크는 access time이 매우 크다. → 상대적으로 느리다.
- 이렇게 메모리 종류마다 가지는 이점이 다양하기 때문에 각각의 이점으로 모두 활용하기 위해 메모리 구조를 여러 구조로 나눈 것이다.



# How hardware devices work together



## high level program

대표적으로 C, Java, Python 등으로 짜여진 프로그램을 말한다.

우리가 흔히 사용하는 프로그램들은 대부분 high level program이다. cpu는 이 프로그램의 명령어 한줄 한줄을 실행하여 우리 원하는 동작을 하게 하는데, cpu는 바이너리 코드인 0과 1밖에 읽을 줄 모르기 때문에 high level의 언어로 구성된 코드를 변환해주는 작업이 필요하다. (물론 high level 상태의 코드를 하드디스크에 저장하지도 못한다. 이 역시 바이너리 코드 형태로 변환되어 저장되어야햔다.)

이 역할을 하는 것이 컴파일러다. 컴파일러는 인간이 이해할 수 있는 고 수준 언어를 기계가 이해할 수 있는 저 수준 언어 - 기계 코드로 바꿔주는 변환기라 할 수 있다.



## RAM와 HD의 차이점

cpu는 기본적으로 하드디스크를 직접 접근할 수 없다. 오로지 RAM으로만 접근할 수 있다.

그리고 RAM은 하드 디스크보다 매우 적은 용량을 가진다. 반대로 하드디스크는 RAM에 비해 많은 용량을 가지는데 그 이유는 상대적으로 가격이 저렴하기 때문이다.

그래서 모든 프로그램 정보를 저장하고 있는 하드디스크의 내용물을 전부 RAM으로 가져오는 것은 불가능하다.

CPU가 프로그램 P를 실행시켜야한다면 우선 RAM에 P가 적재되어 있는지 확인한다. RAM에 프로그램이 있다면 이를 가져와(fetch) 실행시킨다. (이 행위는 누가하는 것인지...?) CPU에 RAM에 접근하는 시간은 (access time)은 매우 짧다.(빠르다)

만약 RAM에 CPU가 찾는 프로그램이 없다면 하드디스크에서 해당 프로그램의 복제본을 만들고 RAM으로 가져오게 된다. (이 행위를 누가하는 것이지...?)

하드디스크는 상대적으로 access time이 크기 때문에 (시간이 많이 걸리기 때문에) CPU가 프로그램을 처리하는데 까지 많은 시간이 걸리게 된다.



# Need for OS from Scratch



프로그램이 하드디스크에 총 500개가 있다고 가정해보자.

그리고 RAM에는 총 50개의 프로그램까지밖에 적재되지 않는다.

기본적으로 CPU는 RAM 에 접근하는 속도가 매우 빠르기 때문에 CPU가 처리해야하는 프로그램이 RAM에 모두 있다면 그 처리 속도는 정말 빠를 것이다. 하지만 그렇지 못한다면 이는 매우 오래걸리는 행위가 된다.

그래서 500개 하드디스크에 있는 모든 프로그램을 RAM에 적재할 수 없으니 CPU가 원하는 프로그램을 알맞게 RAM에 적재시키는 것이 매우 중요하다. 즉, CPU가 다음에 요구할 프로그램을 에측할 필요가 있는데, 이 알고리즘이 OS 에 구현돼있다.

## 

# How Input and Output devices  work together



## OS space vs User space

- 컴퓨터를 시작하게 되면 OS 프로그램은 RAM에 적재된다. OS도 하나의 소프트웨어다.
- RAM은 주소로 이뤄져있는데, OS code가 적재되는 주소를 OS space라고 한다. 이 곳은 OS가 적재되는 공간이다.
- 그리고 그 외 나머지 공간에 우리가 흔히 사용하는 소프트웨어 프로그램들이 적재된다. 이 공간을 user space라고 한다. CPU에 처리된 user space의 프로그램들은 RAM에서 삭제된다.

## I/O Device

키보드나 마우스로 사용자의 입력을 받거나 모니터나 프린트기와 같이 사용자에게 데이터를 출력시켜주는 장비를 말한다. 뿐만 아니라 영속화된 데이터를 읽고 쓸 수 있는 HD 또한 하나의 I/O 장비라고 할 수 있다.

> 키보드나 모니터와 같은 I/O 장비들은 각각의 버퍼를 가지고 있다. 버퍼는 간단하게 메모리라고 생각하면 된다.

### 왜 버퍼가 필요할까?

계산기 소프트웨어를 예로 들어보자.

2 + 3 // 계산 결과 : 5

- 하드디스크에 있던 계산기 프로그램은 사용자에 의해 실행되기 위해 RAM에 적재된다.

- 위 2, 3이라는 숫자는 키보드를 통해 입력될 것이다.

- 처음 입력된 2라는 숫자는 010이라는 바이너리 코드로 버퍼에 저장되고 이 데이터가 RAM으로 이동한다. 3 숫자 역시 011이라는 숫자로 버퍼에 저장(overwrite)되고 RAM으로 이동된다.

- 여기까지 RAM에는 OS code, 계산기 소프트웨어, 010, 010 데이터가 적재되어 있을 것이다.

- 그리고 010, 011인 operand는 CPU에 의해 레지스터에 적재된다.

  (CPU 역시 버퍼 또는 레지스터를 가지고 있다.)

- 그리고 이 레지스터에 저장된 데이터는 + 연산이 끝난 이후 011, 010이 저장되어 있는 레지스터 두개 중 하나에 101 (5) 결과값이 덮어쓰여진다.

- 계산은 CPU에 의해 이뤄진다.

- CPU는 control unit, arithmatic and logic unit 이렇게 두가지로 구성되어 있는데, 여기서 arithmatic and logic unit이 더하기 연산을 한 것이다. (ALU 회로에 의해 계산된다.)

- 그렇게 계산의 결과 값은 다시 RAM에 적재된다.

- 그리고 그 결과 값을 사용자에게 보여줘야하기 때문에 모니터 버퍼로 이동된다.

문서를 수정한다는 예를 들어보자.

- A 라는 문서는 하드디스크에 저장되어 있다.
- 사용자는 A 문서를 수정하기위해 A문서를 실행시킨다. (A 문서를 여는 프로그램은 가상의 Z라는 프로그램을 사용한다고 치면 Z 프로그램 또한 A 문서와 함께 RAM에 적재될 것이다.)
- 사용자는 키보드로 수정할 문자를 입력한다. 입력된 문자는 키보드 버퍼에 저장 후 바이너리 형태로 RAM으로 이동하게 되고 여러가지 명령어가 CPU에 의해 처리되어 원하는 내용으로 수정될 것이다.
- 그리고 이 A 문서는 다시 저장되어야한다. 그러기 위해 RAM에 있는 A 문서를 다시 하드디스크로 옮긴다.
- 이 과정에서 우리가 알 수 있는 것은 하드디스크 또한 I/O 장비라고 할 수 있다는 것이다. 어쨌든 사용자 명령을 실행시키기 위해 Input 장비로 부터 데이터를 입력받는 행위와 하드디스크로부터 필요한 데이터를 꺼내오는 것이 비슷한 맥락이기 때문이다. 모니터로 연산된 결과값을 보여주는 것과 마찬가지로 수정한 문서를 영구적으로 저장하는 것도 비슷한 맥락으로 볼 수 있다.

*RAM에 적재된 프로그램들은 I/O 장비로부터 어떠한 데이터를 주거나 받기위해 기다리는 시간을 갖는다.(I/O event)*

### Turn-around Time

- waiting time + burst time(execution time) + I/O time
- 프로그램이 RAM 에 적재되고나서부터 CPU 처리 이후 완전히 RAM에서 제거되기 까지의 걸리는 시간
- Execution : CPU에 의해 프로그램이 처리되는 것
- I/O Event : I/O 장비로부터 특정 값을 주거나 받기 행위가 일어나는 것
- waiting : CPU 처리나 I/O 장비로 부터 이벤트를 받기 전 후에 놓인 상태



# Program vs Process, State of a process



우리 컴퓨터에 크롬과 워드 프로그램이 깔려있다고 가정해보자.

누군가가 high level 언어로 만든 크롬과 워드라는 프로그램은 컴파일러에 의해 기계어 (Machine Code)로 변환되고 우리 컴퓨터 하드디스크에 저장되어 있다.

우리가 크롬 아이콘을 더블 클릭했을 때,

CPU는 제일 먼저 RAM에서 크롬 프로그램(소프트웨어)를 찾는다.

만약 RAM에 해당 프로그램이 없다면 하드디스크에 있던 크롬 프로그램이 copy&paste 되어 RAM에 적재된다.

여기서 하드디스크에 있던 크롬 프로그램이 RAM에 적재되기 전에 복사가 먼저 되는데, 복사된 크롬 프로그램을 프로세스라고 부른다.

크롬을 실행시키면서 복제된 크롬 프로그램이 하나 생기는데 여기서 사용자가 크롬 창을 새롭게 연다면 다시 크롬 프로그램이 복제된다. 복제된 프로그램 역시 프로세스이며 하드디스크에는 크롬 프로그램 하나와 크롬 프로세스 두 개가 존재하게 된다.

이렇게 생성된 프로세스들은 RAM으로 옮겨지고 CPU에 의해 처리된다.

그렇게 RAM으로 옮겨진 프로그램 / 프로세스는 CPU에 의한 처리(execute), I/O 이벤트 지연(waiting for I/O event), 그외 처리 지연(waiting for some event or being executed by cpu)의 여러가지 상태(stage)에 놓인다.

## Stated of a process

- new state
  - 사용자가 크롬 프로그램을 실행시키기는 명령을 내렸을 때 하드디스크에 저장되어 있던 구글 프로그램이 새로운 구글 프로세스를 복제 / 만들어 내는데 이때 새롭게 생성된 프로세스 상태는 new state이다.
- ready state
  - 그렇게 복재 / 생성된 프로세스는 RAM으로 이동하게 된다. RAM에 옮겨지게 되면 cpu에 의해 처리될 수도 있고 I/O 이벤트를 위해 기다릴수도 있는데 이렇게 어떠한 처리가 될 수 있는 기다리고 있는 상태에 프로세스를 ready state라고 한다.
- running state
  - cpu에 의해 한줄 한줄 씩 처리되는 프로세스의 상태는 running state다.
- I/O state
  - I/O 장비에 의해 처리(read, write)되는 프로세스의 상태를 I/O state라고 한다.
- terminated state
  - RAM에서 처리가 완료된 프로세스의 상태를 terminated state 라고 한다. 이 상태에 놓은 프로세스는 RAM에서 제거된다.
- suspend ready state
- suspend wait state



# Types of Operation Systems



## Batch OS

- 지금은 많이 사용하지 않는 오래된 운영체제 종류다.
- degree of multiprogramming이 1인 운영체제
- 즉 RAM에 적재될 수 있는 프로그램 / 프로세스의 갯수가 최대 한개다.
- 병렬로 처리할 수 있는 멀티 프로그램 환경에 비해 매우 비효율적
  - RAM에 있는 오직 하나의 프로세스는 CPU에 의해 처리되다가도 I/O 처리가 이뤄지는 순간 CPU는 일을 멈추게 되고 놀게 된다. → 비효율, CPU efficiency 가 낮다.
  - CPU efficiency
    - useful time of cpu / total time of cpu

## MultiProgramming OS

- RAM에 하나 이상의 프로세스가 적재되어 처리되는 환경의 OS
- CPU efficiency가 매우 높다.
- 즉, 컴퓨터 속도가 빠르다.
- 동시 처리가 가능하다. → concurrent processing
  - 그러나 병렬로 처리되는 것은 아니다.

## MultiProcessing OS

- 위 두 개 OS 환경과 다르게 CPU가 두개 이상인 OS
- 병렬 처리가 가능하다. → parallel processing

### Parallel Processing

- 여러 개의 cpu로 동시에 여러개의 프로세스를 처리하는 방식
- 동시 처리 방식보다 빠른 속도를 자랑한다.
- 그러나 비용이 매우 증가한다. → cpu가 여러개여야 하기 때문
- 현재 상용화된 컴퓨터에서 사용되는 처리 환경이다.
  - 쿼드코어 프로세서, 옥타코어 프로세서 등

### Concurrent Processing

- 오직 하나의 cpu로 프로세스를 번갈아가면서 처리하는 방식



# Process Control Block, Attribute of a process



## Passive Entity

사용자에 의해 실행될 프로세스의 모체되는 프로그램. 이 Passive Entity는 직접 프로세서에 의해 처리되는 것이 아니라 처리될 프로세스를 만들어내는 복제의 근원이 된다.

## Active Entity

프로세서에 의해 처리될 프로세스를 말한다. 즉, 사용자가 실행시킬 프로그램으로부터 복제되어 새롭게 생성된 프로세스를 active entity라고 한다.

## Process Control Block. PCB

- 프로그램은 함수, 명렁어의 집합이다.
- 프로세스는 이런 프로그램을 포함하며 그외 다른 데이터도 가지고 있다.
- 기본적으로 stack 스택 메모리가 있다.
  - 함수를 호출하는 순서대로 스택 메모리에 쌓고 하나씩 꺼내면서 함수를 처리한다.
  - 이렇게 호출되는 함수는 스택이라는 특성을 이용해 추적(trace)할 수 있다.
- 스택 메모리와 더불어 heap 힙 메모리 영역이 있다.
  - heap에는 동적 메모리 할당이 이뤄진다.
    - malloc, calloc
- 스택과 힙 메모리는 정확하게 특정 메모리 주소로 나눠지는 것이 아니다.
  - 이는 메모리의 구분은 유동적이며 프로그램의 특성에 따라 동적 메모리 할당이 더 많이 필요한 경우에는 힙 메모리를 많이 할당하며 스택 메모리 또한 필요한 경우 힙 영역보다 더 많은 공간을 차지할 수 있다.
- 전역 변수 global variable 과 정적 변수 static variable 은 스택 메모리에 할당되는 것이 아닌 이 변수를 따로 저장하는 공간에 저장된다.
- 위 개념들을 모두 포괄하여 PCB라고 한다.
  - 이 PCB는 프로세스 별 하나씩 갖게 된다.

## Process Attributes

- Process Id
  - unique number
  - 모든 프로세스는 유니크 번호(prcess id)를 할당받는다.
  - OS의 스케줄러가 프로세스를 cpu에 할당할 때 어떤 프로세스를 할당할지 결정하게 되는데 그때 프로세스를 인지하기 위해 사용되는 속성이다.
- Program counter
  - 스케줄러에 의해 프로세스가 CPU에 할당되는데 모든 명령어가 실행되기 전에 다른 프로세스가 CPU에 할당되는 상황이 온다면 현재 프로세스가 어디까지 처리됐는지 알아야하는데 그때 사용하는 것이 program counter (pc)다.
  - pc를 이용해 다시 미 완료된 ready state의 프로세스가 CPU에 할당되면 어디부터 처리를 시작하면 되는지 알 수 있다.
  - pc는 하나의 레지스터다.
- Process state
- General purpose registers
  - 실제 프로세스에서 사용되는 레지스터 값을 기억하는 레지스터다.
- Priority
  - 프로세스의 우선순위를 말하며 OS 스케줄러에 의해 해당 프로세스의 우선수위가 결정된다.
  - OS에는 다양한 알고리즘에 의해 구현된 여러가지 스캐줄러가 있다. 스케줄러 별 특징은 매우 중요한 개념이다!
- List of open files
  - 기존에 CPU에 할당된 프로세스가 오픈한 (접근한) 파일에 처리 상황을 저장한다. 즉, 현재 CPU에 할당된 프로세스가 특정 파일을 읽고 read 있다가 다른 프로세스의 할당으로 강제로 처리가 멈추게 될 때 읽고 있던 파일의 마지막으로 읽은 정보를 기억하고 있다가 후에 다시 CPU에 할당됐을 때 파일을 마저 읽을 수 있게 된다.
- List of open devices
  - 위 List of open files와 매우 비슷하다. 파일이 아닌 장비, 예를 들어 프린터라면 프린트를 하는 도중에 강제로 다른 프로세스가 CPU에 할당되어 멈추게 된다면 마지막으로 프린트한 부분을 기억하여 후에 그 다음부터 프린트될 수 있도록 정보를 기억하는 공간이다.
- Protection
  - 프로세스간에 메모리 공간을 공유할 수 없게 막는 개념이다. 이렇게 프로세스 간 메모리를 공유할 수 없게 OS가 처리한다.