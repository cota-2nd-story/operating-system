# 가상 메모리

### **what?**

주 메모리(RAM)의 물리적, 비용적 한계를 극복하기 위해 서브 메모리(HDD)을 활용해 프로세스가 더 많은 메모리를 활용할 수 있도록 하는 것이다.

프로세스는 각자 고유의 가상 주소 공간을 가지며 서로의 주소 공간에 접근 할 수 없다. 각 프로세스가 가진 접근하는 가상의 주소 값이 그 자체로 같다고 하더라도 실제 물리 주소는 다르다고 할 수 있다. 프로세는 가상 주소에만 접근하니 물리 주소는 어디에 있든 상관이 없게 된다. 실제 물리 주소가 있는 하드웨어로 RAM과 HDD를 모두 사용할 수 있게 되어 실제 RAM 공간보다 더 큰 리소스를 프로세스 실행에 이용 할 수 있다.

- 가상 주소(virtual address): 프로세스가 참조하는 주소
- 물리 주소(physical address): 실제 메모리 주소

### **why?**

- 비용을 낮춘다: 비교적 비용이 적은 HDD를 프로세스 실행에 이용 할 수 있어 비용을 줄일 수 있다.
- 성능을 높인다: 각 프로세스가 이용가능한 메모리의 크기가 증가한다

### How?

OS가 가상 메모리를 활용하는 기법으로 **Demand-Paging** 기법이 있다. 디스크 상에 paging file(swap file)을 두고 모든 프로세스가 사용할 수 있는 가상 메모리로 사용할 수 있도록 한다. Demand-Paging 기법과 관련된 몇가지 개념을 살펴보면,

- Page: 가상 메모리를 사용하는 최소 단위, 메모리 공간의 fragmentation을 최대한 방지하기 위함. 4Kb(1024bit)
- Page가 사용하는 가상 주소의 구조: 가상 주소 v = (p, d) (p: 가상 메모리 페이지 번호, d: p 안에서 참조하는 위치) / e.g. 페이지의 크기가 8Kb이고 페이지의 주소가 0번째 bit에서 시작한다면 이 페이지는 23번째 bit 공간까지의 변위를 가진다. 24bit 이상이 페이지 번호가 될 수 없다.
- Page Table: 가상 메모리의 page와 물리 메모리의 page를 연결하기 위한 mapping table, 순서 쌍으로 정보를 가지고 있다. 다만, table을 통한 탐색은 비용을 발생시키므로 물리 주소 반환을 위한 목적의 MMU라는 하드웨어 장치를 이용해 비용을 줄인다.
- Paging System: Page table을 이용해 가상 메모리에 대응하는 물리 메모리 공간의 주소를 알아내는 구조를 가리킨다.

Demanding-Paging 기법은 필요한 page만 물리 메모리로 가져오는 기법이다. 이때 가상 메모리에 대응하는 물리 메모리 주소를 알기 위해서 Page table이 필요하다. MMU에 Page table 정보와 탐색 알고리즘이 있고 프로세스의 PCB에는 자신의 Page Tabe을 가리키는 주소와 가상 메모리 주소가 들어있다.

해당 프로세스는 PCB에서 페이지 번호(p)와 가상 주소를 이용해 MMU의 Page table에서 물리주소(p')을 알아낸다. 그리고 나서 페이지 변위(d)를 이용해 p'+d 형태로 실제 물리주소를 확정한다.  확정된 물리 주소 공간에는 프로세스가 사용할 수 있는 메모리가 존재하며 이를 paging file(swap file)이라고 한다.

![https://media.vlpt.us/post-images/pa324/b31b9320-080c-11ea-b983-99605d56c9b4/image.png](https://media.vlpt.us/post-images/pa324/b31b9320-080c-11ea-b983-99605d56c9b4/image.png)

위 그림을 통해 확인해보면 Process1의 aspect라는 이름의 데이터(또는 코드)의 실제 물리 주소를 알아내기 위해 우선 Process1의 PCB에서 페이지 번호(p) 값에 해당하는 page3를 얻어낸다. 그리고나서 Process1의 PCB에서 가리키는 Page table에 접근한다. MMU는 페이지 번호 page3에 해당하는 물리주소 1000h를 반환한다. 페이지 변위(d) 값은 2 이므로 실제 물리 주소는 1000h + 2가 된다. 이 주소를 토대로 실제 물리 공간의 주소에 접근한다.