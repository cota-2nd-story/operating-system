# 스레드 & 동시성

Created: Apr 29, 2020 8:04 PM
Tags: 2주차

## 멀티 스레드 프로그래밍이란?

하나의 프로세스 내부에서 여러 스레드가 존재하여 동시 처리되는 프로그래밍

![1](https://user-images.githubusercontent.com/30451129/81290053-5ac23480-90a2-11ea-825e-e68e2325196b.jpeg)

스레드란?

프로그램이 실행되는 최소 단위 또는 흐름의 단위
(하나의 프로세스는 최소 하나의 스레드를 갖는다.)

> 실제 스레드가 작업을 처리하는 것은 아니다. 스레드는 실행(처리)될 작업의 단위일 뿐. 스레드가 포함하는 작업이 CPU의 처리 대상이 된다.

### 멀티 스레드 환경 예시

- 여러 이미지를 동시에 출력하는 웹페이지에서 이미지 렌더링을 하나씩 하는 것이 아닌 동시에 렌더링이 진행된다. → 하나의 프로세스(웹페이지)에서 이미지를 렌더링하는 여러 작업(하나 이상의 스레드)이 동시에 처리된다.
- 웹 브라우저는 사용자에게 이미지나 글을 보여줌과 동시에 서버 응답을 처리힌다. → 웹 브라우저는(프레세스)사용자에게 이미지나 글을 보여주고 서버로부터 받은 응답을 처리하는 것이 아닌 사용자에게 이미지나 글을 보여주는 작업(스레드 1), 서버로부터 응답을 처리하는 작업(스레드 2)가 동시에 처리된다.
- 워드 프로세서는 프로그램의 그래픽 요소를 화면을 통해 사용자에게 보여주면서 사용자의 키보드 입력 값을 받는다. → 워드 프로세서(프로세스)가 작동될 때 화면에 보여줘야하는 구성을 처리하는 작업(스레드 1)과 사용자의 입력 값을 받는 작업(스레드 2)가 동시에 처리된다.

### 멀티 스레드의 이점

- 대응성
    - 하나의 프로세스에서 사용자가 입력한 input에 대한 여러 작업이 동시에 처리됨으로써 사용자 친화적인 경험을 제공해줄 수 있다.
- 자원 공유
    - 프로세스가 같은 자원을 공유하기 위해선 사전 작업이 여럿 요구되는 반면 스레드는 기본적으로 자원을 공유한다. 하나의 프로세스 같은 주소 공간에 여러 스레드를 할당할 수 있다.
- 경제적
    - 프로세스 생성 및 해제(메모리 할당)은 많은 비용이 발생한다. 스레드는 이와 다르게 더 적은 비용으로 생성이 가능하며 context-switch 비용 또한 저렴하다.
- 확장성
    - 멀티 코어 시스템에 맞춰 여러 스레드로 동시 (병렬) 처리를 함으로써  더 빠른 컴퓨터로 발전할 수 있다.

### 멀티코어 프로그래밍

- 단일 cpu 시스템에서는 여러 스레드가 존재해도 결국 한번에 하나씩만 처리된다.
    
    - 단일 코어 시스템에서 동시적으로 처리된다는 것은 여러 프로세스가 동시에 처리되는 것처럼 착각을 일으키기 위해 여러 프로세스에 짧은 시간동안 cpu를 할당하고 여러번의 context-switch를 통해 처리하는 cpu 스케줄러 기법과 매우 흡사하게 작동된다.
- 멀티코어 시스템에서는 실제 처리할 수 있는 프로세서가 둘 이상이기 멀티 스레드환경이라면 프로세스 내부 여러 작업(task)가 실제 동시에 처리될 수 있다.(병렬적)

- *단일 코어 시스템에서 멀티 스레드가 소용이 있을까?*
    - 어차피 처리기는 하나이기 때문에 멀티 스레드여도 의미가 없다고 생각할 수 있다.
    
    - 그러나 스레드는 작업 단위이기 때문에 멀티 스레드 환경이라면 동시에 처리될 대상이 여럿이 된다.

    - 물론 단일 코어이기 때문에 이 여러 작업 대상이 실제 동시에 처리될 순 없지만 작업 단위가 시간 흐름에 맞춰 아래 그림처럼 처리되기를 기다리게 된다.

        ![2](https://user-images.githubusercontent.com/30451129/81290064-5eee5200-90a2-11ea-9b9c-1aabba5062ce.jpeg)
        
    
    - 위 그림 상에서 작업 T1은 총 3번의 나눠서 처리되는데 이는 멀티 스레드 환경이기 때문에 스레드 스케줄러에 의해 이와같이 처리되는 것
    
    - 만약 멀티 스레드가 아니라면 T1 작업이 모두 끝날 때까지 나머지 작업들 (T2, T3, T4)들은 처리 대상으로 존재하지 않았을 것

### 멀티 스레드 모델

- Many-to-One Model
    - 실제 처리를 담당하는 커널 스레드가 하나이고 이 하나의 커널 스레드에 사용자 스레드가 여럿 할당되는 모델이다. 만약 blocking 시스템 콜이 하나의 스레드에 발생하면 프로세스 전체가 멈추게된다. → 실제 처리 작업 단위인 커널 스레드가 block 되기 때문
    - 이와같은 이유 때문에 멀티코어 시스템에서도 병렬적으로 처리가 불가하다.
- One-to-One Model
    - 사용자 스레드 하나에 커널 스레드 하나를 할당하는 모델 → Window, Linux 운영체제가 구현한 가장 일반적인 모델이다.
    - 당연히 커널 스레드가 여러개이기에 멀티 코어 시스템에서 병렬 처리가 가능하다. (하나의 스레드에거 시스템 block이 발생하더라도 처리할 수 있는 스레드는 그외 존재하기 때문에 프로세스가 멈추는 상황이 발생하지 않는다.)
    - 사용자 스레드가 많아질수록 커널 스레도도 많아지기 때문에 시스템 과부하로 이어질 수 있기에 적정 갯수의 스레드 생성이 중요하다.
- Many-to-Many Model
    - 여러 사용자 스레드와 사용자 스레드 갯수 이하의 갯수만큼 존재하는 커널 스레드가 다대다 관계를 갖는 모델
    - One-to-One, Many-to-One 장점을 모아놓은 모델이다.
    - 그러나 구현이 힘들다는 단점과 코어의 갯수가 나날이 증가하는 추세에 따라 One-to-One 모델의 단점이 보완됨에 따라 인기가 높지 않다.

### Implicit Threading

- 스레드 생성 관리를 개발자에게 위임하는 것이 아닌 운영체제나 컴파일러에게 위임하는 방식
- 종류 (Java 기준)
    - Thread Pool
        - 스레드를 무한정으로 만들 수 없는 환경이기 때문에 멀티 스레드 환경에서 동시 처리를 위해 미리 스레드를 만들어놓은 방식
        - 스레드 모델을 producer-consumer 모델을 적용함으로써 구현 가능한
            
            - *스레드 생성과 실행을 분리한 모델*
- 실제 서버가 Thread Pool 사용 (tomcat)
        
    ![3](https://user-images.githubusercontent.com/30451129/81290067-60b81580-90a2-11ea-9167-081771ccbe8f.jpeg)
        
    - Fork Join
        - 병렬 처리를 효율적으로 지원할 수 있는 스레드 생성 방식
        - divide-and-conquer 의 재귀 호출 알고리즘
        - 처리해야할 작업을 하나의 스레드가 담당할 수 있는 범위까지 반으로 쪼개고 이를 다시 합치는 방식
            - 그렇게 하나의 작업이 여러 단위로 쪼개져 여러 스레드에 할당받으면 동시 처리 가능
        - *하나의 부모 스레드에서 생성된 여러 자식 스레드는 병렬 처리가 가능하기 때문*
    
            ![4](https://user-images.githubusercontent.com/30451129/81290070-6281d900-90a2-11ea-8daf-49cab0541ac0.jpeg)